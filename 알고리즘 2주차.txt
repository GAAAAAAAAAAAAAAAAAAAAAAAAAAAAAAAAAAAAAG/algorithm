싸이클이 되는지 안되는지 확인
선을 하나 지우고 연결이 되는지 확인하기
중간에 이미 가본 데가 발견하면 갈 필요가 없으니 돌아간다.

챕터2
알고리즘
-문제를 해결하는 단계적 절차

<특성>
정확성 : 주어진 입력에 대해 올바른 해를 주어야
수행성 :각 단계는 컴퓨터 수행 가능하여야
유한성 : 유한 시간 내에 종료 되어야
효율성 : 효율적일 수록 그 가치가 높다.

<최초의 알고리즘>
유클리드의 최대공약수 알고리즘

Euclid(a,b)
입력 : 정수 a,b; 단, a>=b>=0
출력 : 최대공약수 (a,b)

1. if b==0 return a
2. return Euclid(b, a mod b)

<알고리즘의 표현 방법>
알고리즘의 형태는 단계별 절차이므로, 마치 요리책의 요리를 만드는 절차와 유사

알고리즘의 각 단계는 보통 말로 서술할 수 있으며, 컴퓨터 프로그래밍 언어로만 표현할 필요는 없음

알고리즘은 대부분 의사코드(pseudo code)로 표현(수도 코드 : 비슷한데 다르다)

플로우 차트(flow chart)

<알고리즘의 분류>
-문제의 해결 방식에 따른 분류
분할정복
그리디
동적 계획
근사 : 실제 값을 구하기 어려울 때 근사 값을 구하자(날씨 구하기)
백트래킹
분기 한정

-문제에 기반한 분류
정렬
그래프
기하

-특정 환경에 따른 분류
병렬
분산
...

<알고리즘의 효율성>
알고리즘의 수행 시간 또는 알고리즘이 수행하는 동안 사용되는 메모리 크기로 나타낼 수 있다.
시간 복잡도, 공간 복잡도
일반적으로 알고리즘들을 비교할 때는 시간 복잡도가 주로 사용됨
(달라지는 것이 시간 복잡도로 많이 달라지기때문에, 시간 복잡도가 같으면 공간 복잡도를 비교함)

<시간 복잡도>
알고리즘이 실행되는 동안에 사용된 기본적인 연산 횟수를 입력 크기의 함수로 나타낸다.
기본연산 : 데이터 간 크기 비교, 데이터 읽기, 갱신, 숫자 게산 등과 같은 단순한 연산

<알고리즘의 복잡도 표현 방법>
최악 경우 분석 : 어떤 입력이 주어지더라도 알고리즘의 수행시간이 얼마 이상은 넘지 않는다 라는 상한을 의미
평균 경우 분석 : 입력의 확률 분포를 가정하여 분석하는데, 일반적으로 균등 분포를 가정
최선 경우 분석 : 가장 빠른 수행시간을 분석하며, 최적 알고리즘을 찾는데 활용

상각 분석

일반적으로 알고리즘의 수행 시간은 최악 경우 분석으로 표현

대표적인 분석 예제 : 크러스컬의 최소 신장 알고리즘

<복잡도의 점근적 표기>
시간 복잡도는 입력 크기에 대한 함수로 표기

점근적 표기
입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법
빅O표기 : 점근적 상한
오메가 : 점근적 하한
세타 표기 : 동일한 증가율

O(Big-Oh)표기법을 찾는 간단한 방법
다항식에서 최고 차수 항만을 취한 뒤, 그 항의 계수를 제거하여 g(n)을 정한다.

오메가 표기
하한

세타 표기
상한과 하한 모두 만족
O와 Omega모두 만족

알고리즘 얘기할 때는 세타, 표기는 빅-오

<자주 사용하는 O-표기>
O(1)	상수 시간
O(logN)	로그 시간
O(n)	선형 시간
O(nlogn)	로그 선형 시간
O(n^2)	이차 시간 : 이정도면 오래걸리긴한데 할만 해
O(n^3)	삼차 시간 : 어우 오래걸려
O(n^k)	다항식 시간
O(2^n)	지수 시간 : 못푸는 문제(날씨를 구하는 문제)

10억개 정렬하는데 PC에서 O(n^2) 알고리즘은 300년, O(nlogn)알고리즘은 5분
>> 효율적 알고리즘의 필요성




































